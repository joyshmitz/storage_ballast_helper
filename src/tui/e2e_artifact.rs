//! Structured e2e artifact schema for dashboard test correlation and diagnosis.
//!
//! Provides a canonical, machine-readable format for test run artifacts so that
//! dashboard test failures always include enough context for post-mortem analysis.
//! Every artifact bundle carries trace IDs for cross-correlation between
//! unit, integration, and e2e layers.
//!
//! # Design (bd-xzt.4.12)
//!
//! - **TestRunBundle** wraps an entire test suite execution.
//! - **TestCaseArtifact** captures one case: trace ID, timing, output, assertions,
//!   frame captures (for dashboard harness tests), and diagnostics.
//! - **ArtifactCollector** provides an incremental builder that accumulates cases
//!   and finalizes into a bundle.
//! - **Validation**: `validate_minimum_payload` ensures every failing case has at
//!   least one diagnostic entry and captured output, catching silent failures.
//!
//! # Naming Convention
//!
//! Bundle files: `{suite}_{run_id}_{timestamp}.json`
//! Default directory: `$TMPDIR/sbh-test-artifacts/` (overridable via `SBH_ARTIFACT_DIR`)

use std::collections::HashMap;
use std::fmt;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use serde::{Deserialize, Serialize};

// ──────────────────── trace ID generation ────────────────────

/// Monotonic counter for trace ID uniqueness within a process.
static TRACE_SEQ: AtomicU64 = AtomicU64::new(0);

/// Generate a trace ID from timestamp + monotonic counter.
///
/// Format: `sbh-{epoch_ms}-{seq}` — unique within a process via atomic counter.
pub fn generate_trace_id() -> String {
    let epoch_ms = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::ZERO)
        .as_millis();
    let seq = TRACE_SEQ.fetch_add(1, Ordering::Relaxed);
    format!("sbh-{epoch_ms:013}-{seq:08x}")
}

/// Generate a short run ID: `{suite}-{epoch_secs}`.
pub fn generate_run_id(suite: &str) -> String {
    let epoch_secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::ZERO)
        .as_secs();
    format!("{suite}-{epoch_secs}")
}

// ──────────────────── core schema ────────────────────

/// Outcome of an entire test run.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum RunStatus {
    /// All cases passed.
    Pass,
    /// At least one case failed.
    Fail,
    /// Some cases passed, some skipped/timed out, none failed.
    Partial,
}

impl fmt::Display for RunStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Pass => write!(f, "pass"),
            Self::Fail => write!(f, "fail"),
            Self::Partial => write!(f, "partial"),
        }
    }
}

/// Outcome of a single test case.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum CaseStatus {
    Pass,
    Fail,
    Timeout,
    Skipped,
}

impl CaseStatus {
    /// Whether this status counts as a failure for run-level aggregation.
    pub fn is_failure(self) -> bool {
        matches!(self, Self::Fail | Self::Timeout)
    }
}

impl fmt::Display for CaseStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Pass => write!(f, "pass"),
            Self::Fail => write!(f, "fail"),
            Self::Timeout => write!(f, "timeout"),
            Self::Skipped => write!(f, "skipped"),
        }
    }
}

/// Top-level artifact bundle for a complete test suite execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestRunBundle {
    /// Schema version for forward compatibility.
    pub schema_version: u32,
    /// Unique run identifier: `{suite}-{epoch_secs}`.
    pub run_id: String,
    /// Suite name (e.g. "dashboard-headless", "dashboard-e2e", "integration").
    pub suite: String,
    /// ISO 8601 UTC start time.
    pub started_at: String,
    /// ISO 8601 UTC end time.
    pub finished_at: String,
    /// Wall-clock duration in milliseconds.
    pub elapsed_ms: u64,
    /// Aggregate outcome.
    pub status: RunStatus,
    /// Individual test cases.
    pub cases: Vec<TestCaseArtifact>,
    /// Execution environment metadata.
    pub environment: EnvironmentInfo,
    /// Aggregate counts.
    pub summary: RunSummary,
    /// Validation warnings generated by `validate_minimum_payload`.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub validation_warnings: Vec<String>,
}

/// Environment metadata captured at test-run start.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentInfo {
    /// sbh version string.
    pub sbh_version: String,
    /// OS identifier.
    pub os: String,
    /// CPU architecture.
    pub arch: String,
    /// Rust compiler version (if available).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rust_version: Option<String>,
    /// Cargo feature flags active during the run.
    pub features: Vec<String>,
    /// Arbitrary key-value pairs (e.g. env vars).
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub extra: HashMap<String, String>,
}

impl Default for EnvironmentInfo {
    fn default() -> Self {
        Self {
            sbh_version: env!("CARGO_PKG_VERSION").to_string(),
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),
            rust_version: option_env!("RUSTC_VERSION").map(String::from),
            features: Vec::new(),
            extra: HashMap::new(),
        }
    }
}

/// Aggregate counts for a test run.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunSummary {
    pub total: u32,
    pub passed: u32,
    pub failed: u32,
    pub timed_out: u32,
    pub skipped: u32,
}

impl RunSummary {
    /// Derive summary from a list of case artifacts.
    pub fn from_cases(cases: &[TestCaseArtifact]) -> Self {
        let mut s = Self {
            total: u32::try_from(cases.len()).unwrap_or(u32::MAX),
            passed: 0,
            failed: 0,
            timed_out: 0,
            skipped: 0,
        };
        for c in cases {
            match c.status {
                CaseStatus::Pass => s.passed += 1,
                CaseStatus::Fail => s.failed += 1,
                CaseStatus::Timeout => s.timed_out += 1,
                CaseStatus::Skipped => s.skipped += 1,
            }
        }
        s
    }
}

// ──────────────────── test case artifact ────────────────────

/// Full artifact for a single test case execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCaseArtifact {
    /// Unique case ID within the run (auto-generated or user-supplied).
    pub case_id: String,
    /// Trace ID for cross-layer correlation.
    pub trace_id: String,
    /// Human-readable case name.
    pub name: String,
    /// Optional grouping section (e.g. "navigation", "pressure_response").
    #[serde(skip_serializing_if = "Option::is_none")]
    pub section: Option<String>,
    /// ISO 8601 start time.
    pub started_at: String,
    /// ISO 8601 end time.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finished_at: Option<String>,
    /// Duration in milliseconds.
    pub elapsed_ms: u64,
    /// Case outcome.
    pub status: CaseStatus,
    /// Process exit code (for CLI-spawned tests).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exit_code: Option<i32>,
    /// Captured stdout/stderr.
    pub output: CapturedOutput,
    /// Individual assertion results.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub assertions: Vec<AssertionRecord>,
    /// Dashboard frame captures (only populated for TUI harness tests).
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub frames: Vec<FrameCapture>,
    /// Diagnostic messages (errors, warnings, info).
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub diagnostics: Vec<DiagnosticEntry>,
    /// Freeform tags for filtering (e.g. "smoke", "regression", "pressure").
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<String>,
}

/// Captured process output.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CapturedOutput {
    /// Standard output.
    pub stdout: String,
    /// Standard error.
    pub stderr: String,
    /// Whether output was truncated due to size limits.
    pub truncated: bool,
}

/// Maximum bytes to retain per output stream before truncation.
pub const OUTPUT_MAX_BYTES: usize = 512 * 1024; // 512 KiB

impl CapturedOutput {
    /// Create from stdout/stderr strings, truncating if over the limit.
    pub fn new(stdout: String, stderr: String) -> Self {
        let truncated = stdout.len() > OUTPUT_MAX_BYTES || stderr.len() > OUTPUT_MAX_BYTES;
        Self {
            stdout: truncate_string(stdout, OUTPUT_MAX_BYTES),
            stderr: truncate_string(stderr, OUTPUT_MAX_BYTES),
            truncated,
        }
    }
}

/// A single assertion result within a test case.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssertionRecord {
    /// Short description of what was asserted.
    pub label: String,
    /// Whether the assertion passed.
    pub passed: bool,
    /// What was expected (stringified).
    pub expected: String,
    /// What was observed (stringified). Absent for passing assertions to save space.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actual: Option<String>,
    /// Source location (file:line) if available.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
}

/// A captured dashboard frame for TUI harness tests.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FrameCapture {
    /// Monotonic tick when the frame was captured.
    pub tick: u64,
    /// Active screen name.
    pub screen: String,
    /// Active overlay, if any.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub overlay: Option<String>,
    /// Whether the dashboard was in degraded mode.
    pub degraded: bool,
    /// The command returned by the last model update.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_cmd: Option<String>,
    /// Full rendered text of the frame.
    pub text: String,
}

/// Maximum number of frames to retain per case to bound artifact size.
pub const FRAME_CAPTURE_LIMIT: usize = 200;

/// A diagnostic message attached to a test case.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiagnosticEntry {
    /// Severity: "info", "warn", or "error".
    pub level: String,
    /// Human-readable diagnostic message.
    pub message: String,
    /// Component or subsystem that generated the diagnostic.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// ISO 8601 timestamp.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ts: Option<String>,
}

#[allow(clippy::return_self_not_must_use)]
impl DiagnosticEntry {
    pub fn info(message: impl Into<String>) -> Self {
        Self {
            level: "info".into(),
            message: message.into(),
            source: None,
            ts: None,
        }
    }

    pub fn warn(message: impl Into<String>) -> Self {
        Self {
            level: "warn".into(),
            message: message.into(),
            source: None,
            ts: None,
        }
    }

    pub fn error(message: impl Into<String>) -> Self {
        Self {
            level: "error".into(),
            message: message.into(),
            source: None,
            ts: None,
        }
    }

    pub fn with_source(mut self, source: impl Into<String>) -> Self {
        self.source = Some(source.into());
        self
    }
}

// ──────────────────── artifact collector ────────────────────

/// Incremental builder for constructing a [`TestRunBundle`].
///
/// Accumulates test case artifacts, then finalizes into a complete bundle
/// with computed summary and validation.
pub struct ArtifactCollector {
    run_id: String,
    suite: String,
    started_at: SystemTime,
    cases: Vec<TestCaseArtifact>,
    environment: EnvironmentInfo,
    case_counter: u32,
}

#[allow(clippy::return_self_not_must_use)]
impl ArtifactCollector {
    /// Start a new collection run.
    pub fn new(suite: impl Into<String>) -> Self {
        let suite = suite.into();
        Self {
            run_id: generate_run_id(&suite),
            suite,
            started_at: SystemTime::now(),
            cases: Vec::new(),
            environment: EnvironmentInfo::default(),
            case_counter: 0,
        }
    }

    /// Override the environment info.
    pub fn with_environment(mut self, env: EnvironmentInfo) -> Self {
        self.environment = env;
        self
    }

    /// Override the run ID.
    pub fn with_run_id(mut self, run_id: impl Into<String>) -> Self {
        self.run_id = run_id.into();
        self
    }

    /// Start building a new test case, returning a [`CaseBuilder`].
    pub fn start_case(&mut self, name: impl Into<String>) -> CaseBuilder<'_> {
        self.case_counter += 1;
        CaseBuilder {
            collector: self,
            name: name.into(),
            section: None,
            started_at: SystemTime::now(),
            status: None,
            exit_code: None,
            output: CapturedOutput::default(),
            assertions: Vec::new(),
            frames: Vec::new(),
            diagnostics: Vec::new(),
            tags: Vec::new(),
            trace_id: generate_trace_id(),
        }
    }

    /// Add a pre-built case artifact directly.
    pub fn add_case(&mut self, case: TestCaseArtifact) {
        self.cases.push(case);
    }

    /// Number of cases collected so far.
    pub fn case_count(&self) -> usize {
        self.cases.len()
    }

    /// Finalize into a [`TestRunBundle`], computing summary and status.
    pub fn finalize(self) -> TestRunBundle {
        let finished = SystemTime::now();
        let elapsed_ms = u64::try_from(
            finished
                .duration_since(self.started_at)
                .unwrap_or(Duration::ZERO)
                .as_millis(),
        )
        .unwrap_or(u64::MAX);

        let summary = RunSummary::from_cases(&self.cases);
        let status = if summary.failed > 0 || summary.timed_out > 0 {
            RunStatus::Fail
        } else if summary.skipped > 0 {
            RunStatus::Partial
        } else {
            RunStatus::Pass
        };

        let mut bundle = TestRunBundle {
            schema_version: 1,
            run_id: self.run_id,
            suite: self.suite,
            started_at: format_system_time(self.started_at),
            finished_at: format_system_time(finished),
            elapsed_ms,
            status,
            cases: self.cases,
            environment: self.environment,
            summary,
            validation_warnings: Vec::new(),
        };

        bundle.validation_warnings = validate_minimum_payload(&bundle);
        bundle
    }
}

/// Builder for a single test case within an [`ArtifactCollector`].
pub struct CaseBuilder<'a> {
    collector: &'a mut ArtifactCollector,
    name: String,
    section: Option<String>,
    started_at: SystemTime,
    status: Option<CaseStatus>,
    exit_code: Option<i32>,
    output: CapturedOutput,
    assertions: Vec<AssertionRecord>,
    frames: Vec<FrameCapture>,
    diagnostics: Vec<DiagnosticEntry>,
    tags: Vec<String>,
    trace_id: String,
}

#[allow(clippy::return_self_not_must_use)]
impl CaseBuilder<'_> {
    /// Set the grouping section.
    pub fn section(mut self, section: impl Into<String>) -> Self {
        self.section = Some(section.into());
        self
    }

    /// Set the case outcome.
    pub fn status(mut self, status: CaseStatus) -> Self {
        self.status = Some(status);
        self
    }

    /// Set the process exit code.
    pub fn exit_code(mut self, code: i32) -> Self {
        self.exit_code = Some(code);
        self
    }

    /// Set captured output.
    pub fn output(mut self, stdout: String, stderr: String) -> Self {
        self.output = CapturedOutput::new(stdout, stderr);
        self
    }

    /// Add an assertion result.
    pub fn assertion(
        mut self,
        label: impl Into<String>,
        passed: bool,
        expected: impl Into<String>,
        actual: Option<String>,
    ) -> Self {
        self.assertions.push(AssertionRecord {
            label: label.into(),
            passed,
            expected: expected.into(),
            actual,
            location: None,
        });
        self
    }

    /// Add an assertion with source location.
    pub fn assertion_at(
        mut self,
        label: impl Into<String>,
        passed: bool,
        expected: impl Into<String>,
        actual: Option<String>,
        location: impl Into<String>,
    ) -> Self {
        self.assertions.push(AssertionRecord {
            label: label.into(),
            passed,
            expected: expected.into(),
            actual,
            location: Some(location.into()),
        });
        self
    }

    /// Add a frame capture.
    pub fn frame(mut self, capture: FrameCapture) -> Self {
        if self.frames.len() < FRAME_CAPTURE_LIMIT {
            self.frames.push(capture);
        }
        self
    }

    /// Add a diagnostic entry.
    pub fn diagnostic(mut self, entry: DiagnosticEntry) -> Self {
        self.diagnostics.push(entry);
        self
    }

    /// Add tags for filtering.
    pub fn tags(mut self, tags: impl IntoIterator<Item = impl Into<String>>) -> Self {
        self.tags.extend(tags.into_iter().map(Into::into));
        self
    }

    /// Override the trace ID (by default one is auto-generated).
    pub fn trace_id(mut self, id: impl Into<String>) -> Self {
        self.trace_id = id.into();
        self
    }

    /// Finalize the case and add it to the collector. Returns the trace ID.
    pub fn finish(self) -> String {
        let finished = SystemTime::now();
        let elapsed_ms = u64::try_from(
            finished
                .duration_since(self.started_at)
                .unwrap_or(Duration::ZERO)
                .as_millis(),
        )
        .unwrap_or(u64::MAX);

        let status = self.status.unwrap_or_else(|| {
            if self.assertions.iter().all(|a| a.passed) {
                CaseStatus::Pass
            } else {
                CaseStatus::Fail
            }
        });

        let case_id = format!(
            "{}-case-{}",
            self.collector.run_id, self.collector.case_counter
        );
        let trace_id = self.trace_id.clone();

        self.collector.cases.push(TestCaseArtifact {
            case_id,
            trace_id: self.trace_id,
            name: self.name,
            section: self.section,
            started_at: format_system_time(self.started_at),
            finished_at: Some(format_system_time(finished)),
            elapsed_ms,
            status,
            exit_code: self.exit_code,
            output: self.output,
            assertions: self.assertions,
            frames: self.frames,
            diagnostics: self.diagnostics,
            tags: self.tags,
        });

        trace_id
    }
}

// ──────────────────── validation ────────────────────

/// Check that every failing test case has minimum diagnostic payload.
///
/// Returns a list of validation warnings. Empty means all failing cases
/// meet the minimum bar:
/// - At least one diagnostic entry or non-empty stderr
/// - Non-empty `name`
/// - Non-zero `elapsed_ms` or presence of `finished_at`
pub fn validate_minimum_payload(bundle: &TestRunBundle) -> Vec<String> {
    let mut warnings = Vec::new();

    for case in &bundle.cases {
        if !case.status.is_failure() {
            continue;
        }

        let prefix = format!("case '{}' (trace={})", case.name, case.trace_id);

        if case.diagnostics.is_empty() && case.output.stderr.is_empty() {
            warnings.push(format!(
                "{prefix}: failing case has no diagnostics and no stderr output"
            ));
        }

        if case.name.is_empty() {
            warnings.push(format!("case_id={}: missing case name", case.case_id));
        }

        if case.finished_at.is_none() && case.elapsed_ms == 0 {
            warnings.push(format!(
                "{prefix}: no finish timestamp and zero elapsed time"
            ));
        }

        // For dashboard harness tests, failing cases should have at least one frame.
        if !case.tags.is_empty()
            && case.tags.iter().any(|t| t == "dashboard" || t == "tui")
            && case.frames.is_empty()
        {
            warnings.push(format!(
                "{prefix}: dashboard test failure has no captured frames"
            ));
        }
    }

    warnings
}

// ──────────────────── I/O helpers ────────────────────

/// Resolve the artifact output directory.
///
/// Checks `SBH_ARTIFACT_DIR` env var, falls back to `$TMPDIR/sbh-test-artifacts/`.
pub fn artifact_dir() -> PathBuf {
    if let Ok(dir) = std::env::var("SBH_ARTIFACT_DIR") {
        return PathBuf::from(dir);
    }
    std::env::temp_dir().join("sbh-test-artifacts")
}

/// Canonical artifact filename: `{suite}_{run_id}_{epoch}.json`.
pub fn artifact_filename(bundle: &TestRunBundle) -> String {
    let epoch = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::ZERO)
        .as_secs();
    format!("{}_{epoch}.json", bundle.run_id)
}

/// Write a bundle to the artifact directory. Returns the written path.
pub fn write_bundle(bundle: &TestRunBundle) -> std::io::Result<PathBuf> {
    let dir = artifact_dir();
    write_bundle_to(bundle, &dir)
}

/// Write a bundle to a specific directory. Returns the written path.
pub fn write_bundle_to(bundle: &TestRunBundle, dir: &Path) -> std::io::Result<PathBuf> {
    fs::create_dir_all(dir)?;
    let filename = artifact_filename(bundle);
    let path = dir.join(filename);
    let json = serde_json::to_string_pretty(bundle)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;
    fs::write(&path, json)?;
    Ok(path)
}

// ──────────────────── helpers ────────────────────

fn format_system_time(t: SystemTime) -> String {
    let dur = t.duration_since(UNIX_EPOCH).unwrap_or(Duration::ZERO);
    let secs = dur.as_secs();
    let millis = dur.subsec_millis();
    // Simple UTC format without chrono dependency.
    // For test artifacts, second-precision with millis suffix is sufficient.
    format!("{secs}.{millis:03}")
}

fn truncate_string(s: String, max_bytes: usize) -> String {
    if s.len() <= max_bytes {
        return s;
    }
    // Find a char boundary near the limit.
    let mut end = max_bytes;
    while end > 0 && !s.is_char_boundary(end) {
        end -= 1;
    }
    let mut truncated = s[..end].to_string();
    truncated.push_str("\n... [truncated]");
    truncated
}

// ──────────────────── tests ────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    // ── Schema basics ──

    #[test]
    fn run_status_serializes_to_snake_case() {
        assert_eq!(serde_json::to_string(&RunStatus::Pass).unwrap(), "\"pass\"");
        assert_eq!(serde_json::to_string(&RunStatus::Fail).unwrap(), "\"fail\"");
        assert_eq!(
            serde_json::to_string(&RunStatus::Partial).unwrap(),
            "\"partial\""
        );
    }

    #[test]
    fn case_status_serializes_roundtrip() {
        for status in [
            CaseStatus::Pass,
            CaseStatus::Fail,
            CaseStatus::Timeout,
            CaseStatus::Skipped,
        ] {
            let json = serde_json::to_string(&status).unwrap();
            let back: CaseStatus = serde_json::from_str(&json).unwrap();
            assert_eq!(status, back);
        }
    }

    #[test]
    fn case_status_failure_detection() {
        assert!(!CaseStatus::Pass.is_failure());
        assert!(CaseStatus::Fail.is_failure());
        assert!(CaseStatus::Timeout.is_failure());
        assert!(!CaseStatus::Skipped.is_failure());
    }

    // ── Trace ID generation ──

    #[test]
    fn trace_ids_are_unique() {
        let ids: Vec<String> = (0..100).map(|_| generate_trace_id()).collect();
        let unique: std::collections::HashSet<&String> = ids.iter().collect();
        // At least most should be unique (timing collisions vanishingly rare).
        assert!(unique.len() > 90);
    }

    #[test]
    fn trace_id_has_sbh_prefix() {
        let id = generate_trace_id();
        assert!(
            id.starts_with("sbh-"),
            "trace ID should start with 'sbh-': {id}"
        );
    }

    #[test]
    fn run_id_contains_suite_name() {
        let id = generate_run_id("dashboard-headless");
        assert!(id.starts_with("dashboard-headless-"));
    }

    // ── ArtifactCollector ──

    #[test]
    fn collector_empty_run_produces_pass() {
        let collector = ArtifactCollector::new("test-suite");
        let bundle = collector.finalize();
        assert_eq!(bundle.status, RunStatus::Pass);
        assert_eq!(bundle.summary.total, 0);
        assert!(bundle.cases.is_empty());
    }

    #[test]
    fn collector_accumulates_cases() {
        let mut collector = ArtifactCollector::new("unit");
        collector
            .start_case("test_one")
            .status(CaseStatus::Pass)
            .finish();
        collector
            .start_case("test_two")
            .status(CaseStatus::Fail)
            .diagnostic(DiagnosticEntry::error("assertion failed"))
            .output(String::new(), "error details".into())
            .finish();
        assert_eq!(collector.case_count(), 2);

        let bundle = collector.finalize();
        assert_eq!(bundle.status, RunStatus::Fail);
        assert_eq!(bundle.summary.total, 2);
        assert_eq!(bundle.summary.passed, 1);
        assert_eq!(bundle.summary.failed, 1);
    }

    #[test]
    fn collector_auto_detects_status_from_assertions() {
        let mut collector = ArtifactCollector::new("auto");
        // All assertions pass → Pass.
        collector
            .start_case("good")
            .assertion("check", true, "42", None)
            .finish();
        // One assertion fails → Fail.
        collector
            .start_case("bad")
            .assertion("check", false, "42", Some("43".into()))
            .diagnostic(DiagnosticEntry::error("mismatch"))
            .output(String::new(), "mismatch".into())
            .finish();

        let bundle = collector.finalize();
        assert_eq!(bundle.cases[0].status, CaseStatus::Pass);
        assert_eq!(bundle.cases[1].status, CaseStatus::Fail);
    }

    #[test]
    fn collector_skipped_cases_give_partial_status() {
        let mut collector = ArtifactCollector::new("partial");
        collector.start_case("ok").status(CaseStatus::Pass).finish();
        collector
            .start_case("skip")
            .status(CaseStatus::Skipped)
            .finish();

        let bundle = collector.finalize();
        assert_eq!(bundle.status, RunStatus::Partial);
    }

    #[test]
    fn case_builder_sets_section_and_tags() {
        let mut collector = ArtifactCollector::new("tagged");
        collector
            .start_case("nav_test")
            .section("navigation")
            .tags(["smoke", "dashboard"])
            .status(CaseStatus::Pass)
            .finish();

        let bundle = collector.finalize();
        assert_eq!(bundle.cases[0].section.as_deref(), Some("navigation"));
        assert_eq!(bundle.cases[0].tags, vec!["smoke", "dashboard"]);
    }

    #[test]
    fn case_builder_captures_exit_code() {
        let mut collector = ArtifactCollector::new("exit");
        collector
            .start_case("cli_test")
            .status(CaseStatus::Fail)
            .exit_code(1)
            .diagnostic(DiagnosticEntry::error("non-zero exit"))
            .output(String::new(), "error".into())
            .finish();

        let bundle = collector.finalize();
        assert_eq!(bundle.cases[0].exit_code, Some(1));
    }

    #[test]
    fn case_builder_captures_frames() {
        let mut collector = ArtifactCollector::new("frames");
        collector
            .start_case("dashboard_test")
            .frame(FrameCapture {
                tick: 0,
                screen: "Overview".into(),
                overlay: None,
                degraded: false,
                last_cmd: None,
                text: "S1 Overview\npressure: green".into(),
            })
            .frame(FrameCapture {
                tick: 1,
                screen: "Timeline".into(),
                overlay: None,
                degraded: false,
                last_cmd: Some("FetchData".into()),
                text: "S2 Timeline\nevents: 42".into(),
            })
            .status(CaseStatus::Pass)
            .finish();

        let bundle = collector.finalize();
        assert_eq!(bundle.cases[0].frames.len(), 2);
        assert_eq!(bundle.cases[0].frames[0].screen, "Overview");
        assert_eq!(bundle.cases[0].frames[1].tick, 1);
    }

    #[test]
    fn frame_capture_limit_enforced() {
        let mut collector = ArtifactCollector::new("overflow");
        let mut builder = collector.start_case("many_frames");
        for i in 0..FRAME_CAPTURE_LIMIT + 50 {
            builder = builder.frame(FrameCapture {
                tick: i as u64,
                screen: "Overview".into(),
                overlay: None,
                degraded: false,
                last_cmd: None,
                text: format!("frame {i}"),
            });
        }
        builder.status(CaseStatus::Pass).finish();

        let bundle = collector.finalize();
        assert_eq!(bundle.cases[0].frames.len(), FRAME_CAPTURE_LIMIT);
    }

    // ── CapturedOutput ──

    #[test]
    fn captured_output_truncates_oversized() {
        let big = "x".repeat(OUTPUT_MAX_BYTES + 1000);
        let output = CapturedOutput::new(big, String::new());
        assert!(output.truncated);
        assert!(output.stdout.len() <= OUTPUT_MAX_BYTES + 50); // +50 for suffix
        assert!(output.stdout.ends_with("... [truncated]"));
    }

    #[test]
    fn captured_output_preserves_small_data() {
        let output = CapturedOutput::new("hello".into(), "world".into());
        assert!(!output.truncated);
        assert_eq!(output.stdout, "hello");
        assert_eq!(output.stderr, "world");
    }

    // ── Assertions ──

    #[test]
    fn assertion_at_captures_location() {
        let mut collector = ArtifactCollector::new("loc");
        collector
            .start_case("located")
            .assertion_at("eq check", true, "42", None, "src/test.rs:99")
            .status(CaseStatus::Pass)
            .finish();

        let bundle = collector.finalize();
        let a = &bundle.cases[0].assertions[0];
        assert_eq!(a.location.as_deref(), Some("src/test.rs:99"));
    }

    // ── Diagnostics ──

    #[test]
    fn diagnostic_builder_methods() {
        let d = DiagnosticEntry::error("boom").with_source("scanner");
        assert_eq!(d.level, "error");
        assert_eq!(d.message, "boom");
        assert_eq!(d.source.as_deref(), Some("scanner"));

        let w = DiagnosticEntry::warn("careful");
        assert_eq!(w.level, "warn");

        let i = DiagnosticEntry::info("fyi");
        assert_eq!(i.level, "info");
    }

    // ── Validation ──

    #[test]
    fn validation_flags_failing_case_without_diagnostics() {
        let mut collector = ArtifactCollector::new("val");
        collector
            .start_case("silent_fail")
            .status(CaseStatus::Fail)
            .finish();

        let bundle = collector.finalize();
        assert!(!bundle.validation_warnings.is_empty());
        assert!(
            bundle.validation_warnings[0].contains("no diagnostics"),
            "warning: {}",
            bundle.validation_warnings[0]
        );
    }

    #[test]
    fn validation_passes_when_failing_case_has_stderr() {
        let mut collector = ArtifactCollector::new("val_ok");
        collector
            .start_case("noisy_fail")
            .status(CaseStatus::Fail)
            .output(String::new(), "assertion failed at line 42".into())
            .finish();

        let bundle = collector.finalize();
        // stderr counts as diagnostics, so no warning about missing diagnostics.
        assert!(
            !bundle
                .validation_warnings
                .iter()
                .any(|w| w.contains("no diagnostics"))
        );
    }

    #[test]
    fn validation_flags_dashboard_failure_without_frames() {
        let mut collector = ArtifactCollector::new("val_frames");
        collector
            .start_case("no_frames")
            .tags(["dashboard"])
            .status(CaseStatus::Fail)
            .diagnostic(DiagnosticEntry::error("assertion failed"))
            .output(String::new(), "error".into())
            .finish();

        let bundle = collector.finalize();
        assert_eq!(
            bundle
                .validation_warnings
                .iter()
                .filter(|w| w.contains("no captured frames"))
                .count(),
            1
        );
    }

    #[test]
    fn validation_passes_for_passing_cases() {
        let mut collector = ArtifactCollector::new("all_pass");
        collector
            .start_case("ok1")
            .status(CaseStatus::Pass)
            .finish();
        collector
            .start_case("ok2")
            .status(CaseStatus::Pass)
            .finish();

        let bundle = collector.finalize();
        assert!(bundle.validation_warnings.is_empty());
    }

    // ── JSON serialization roundtrip ──

    #[test]
    fn bundle_serializes_to_valid_json_and_back() {
        let mut collector = ArtifactCollector::new("roundtrip");
        collector
            .start_case("case_a")
            .section("core")
            .tags(["smoke"])
            .assertion("eq", true, "1", None)
            .frame(FrameCapture {
                tick: 0,
                screen: "Overview".into(),
                overlay: None,
                degraded: false,
                last_cmd: None,
                text: "hello".into(),
            })
            .status(CaseStatus::Pass)
            .finish();

        let bundle = collector.finalize();
        let json = serde_json::to_string_pretty(&bundle).unwrap();
        let back: TestRunBundle = serde_json::from_str(&json).unwrap();
        assert_eq!(back.suite, "roundtrip");
        assert_eq!(back.cases.len(), 1);
        assert_eq!(back.cases[0].name, "case_a");
        assert_eq!(back.cases[0].frames.len(), 1);
        assert_eq!(back.schema_version, 1);
    }

    #[test]
    fn bundle_optional_fields_omitted_when_empty() {
        let mut collector = ArtifactCollector::new("sparse");
        collector
            .start_case("minimal")
            .status(CaseStatus::Pass)
            .finish();

        let bundle = collector.finalize();
        let json = serde_json::to_string(&bundle).unwrap();
        // Empty vec fields should be omitted.
        assert!(
            !json.contains("\"assertions\""),
            "empty assertions should be omitted"
        );
        assert!(
            !json.contains("\"frames\""),
            "empty frames should be omitted"
        );
        assert!(
            !json.contains("\"diagnostics\""),
            "empty diagnostics should be omitted"
        );
    }

    // ── RunSummary ──

    #[test]
    fn run_summary_counts_correctly() {
        let cases = vec![
            make_case(CaseStatus::Pass),
            make_case(CaseStatus::Pass),
            make_case(CaseStatus::Fail),
            make_case(CaseStatus::Timeout),
            make_case(CaseStatus::Skipped),
        ];
        let s = RunSummary::from_cases(&cases);
        assert_eq!(s.total, 5);
        assert_eq!(s.passed, 2);
        assert_eq!(s.failed, 1);
        assert_eq!(s.timed_out, 1);
        assert_eq!(s.skipped, 1);
    }

    // ── I/O ──

    #[test]
    fn write_bundle_creates_file() {
        let dir = tempfile::tempdir().unwrap();
        let collector = ArtifactCollector::new("io-test");
        let bundle = collector.finalize();

        let path = write_bundle_to(&bundle, dir.path()).unwrap();
        assert!(path.exists());

        let content = fs::read_to_string(&path).unwrap();
        let back: TestRunBundle = serde_json::from_str(&content).unwrap();
        assert_eq!(back.suite, "io-test");
    }

    #[test]
    fn artifact_filename_contains_run_id() {
        let collector = ArtifactCollector::new("naming");
        let bundle = collector.finalize();
        let name = artifact_filename(&bundle);
        assert!(name.starts_with("naming-"));
        assert!(
            std::path::Path::new(&name)
                .extension()
                .is_some_and(|ext| ext.eq_ignore_ascii_case("json"))
        );
    }

    // ── EnvironmentInfo ──

    #[test]
    fn default_environment_has_version() {
        let env = EnvironmentInfo::default();
        assert!(!env.sbh_version.is_empty());
        assert!(!env.os.is_empty());
        assert!(!env.arch.is_empty());
    }

    // ── truncate_string ──

    #[test]
    fn truncate_preserves_char_boundary() {
        // Multibyte UTF-8: each '€' is 3 bytes. "€€" = 6 bytes.
        // Truncating at 4 must not cut in the middle of '€' (at byte offset 3, not 4).
        let s = "€€".to_string(); // 6 bytes
        let t = truncate_string(s, 4);
        // Should truncate to first char boundary <= 4, which is 3 (one '€').
        assert!(t.starts_with('€'));
        assert!(t.contains("[truncated]"));
    }

    #[test]
    fn truncate_noop_for_small_string() {
        let s = "hello".to_string();
        let t = truncate_string(s, 1000);
        assert_eq!(t, "hello");
    }

    // ── Display implementations ──

    #[test]
    fn status_display() {
        assert_eq!(RunStatus::Pass.to_string(), "pass");
        assert_eq!(CaseStatus::Timeout.to_string(), "timeout");
    }

    // ── Helper ──

    fn make_case(status: CaseStatus) -> TestCaseArtifact {
        TestCaseArtifact {
            case_id: "test".into(),
            trace_id: "sbh-0-0".into(),
            name: "test".into(),
            section: None,
            started_at: "0.000".into(),
            finished_at: Some("0.001".into()),
            elapsed_ms: 1,
            status,
            exit_code: None,
            output: CapturedOutput::default(),
            assertions: Vec::new(),
            frames: Vec::new(),
            diagnostics: Vec::new(),
            tags: Vec::new(),
        }
    }
}
